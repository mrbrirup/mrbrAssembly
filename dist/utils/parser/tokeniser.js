class {static get using(){return["Mrbr.Utils.Parser.Token"]}constructor(e){this.types=JSON.parse(e),this.initialBlocks=this.types.initialBlocks,this.whitespace=this.types.whitespace,this.keywords=this.types.keywords,this.objectMethods=this.types.objectMethods,this.operators=this.types.operators,this.blocks=this.types.blocks,this.identifier=this.types.identifier;let t=Mrbr.Utils.Parser.Token.Groups;this.markerRegexes=this.types.markerRegexes.map(e=>({group:t[e.group],name:e.name,rx:new RegExp(e.rx,e.flags)}))}tokenise(e){const t=this.tokeniseQuotes,s=this.tokeniseBlockComment,r=this.tokeniseLineComment,n=this.resetTokenPoints,o=e.length,l=Mrbr.Utils.Parser.Token,i=(l.Groups,this.markerRegexes);let a,p=0,h=[];for(let t,s,r,n=0,a=i.length;n<a;n++)for((t=i[n]).rx.lastIndex=0;null!==(s=t.rx.exec(e));)s.index===t.rx.lastIndex&&t.rx.lastIndex++,s.index>=0&&(r=s.index,h.push({key:s[0],pos:r,sort:r*o-s[0].length,type:"rx",rxResult:s,rxGroupName:t.group,rxTypeName:t.name,lastIndex:t.rx.lastIndex,tokenClass:l}));a=(h=h.sort((e,t)=>e.sort-t.sort))[p];let k=0,u=[h.length];for(;p>=0;){switch(a.key){case'"':case"'":case"`":u[k]=t(a,e,u);break;case"/*":u[k]=s(a,h,p);break;case"//":u[k]=r(a,h,p);break;default:u[k]=new a.tokenClass(a.rxResult.index,a.rxResult[0].length,a.rxGroupName,a.rxTypeName)}k++,a=h[p=n(h,u[u.length-1].end,p)]}return this.populateTokenProperties(u.slice(1,k),e)}fillTokensGaps(e,t){const s=e.length,r=Mrbr.Utils.Parser.Token,n=r.Groups;e[0].start>0&&e.push(new r(0,e[0].start,n.Other));for(let t=0;t<s-1;t++){let s=e[t],o=e[t+1];o.start-s.end>0&&e.push(new r(s.end,o.start-s.end,n.Other))}e[s-1].end<t.length&&e.push(new r(e[s-1].end,t.length-e[s-1].end,n.Other))}populateTokenProperties(e,t){const s=new RegExp(this.identifier,"gim"),r=this.whitespace,n=this.blocks,o=this.operators,l=this.keywords,i=Mrbr.Utils.Parser.Token.Groups;let a=0,p=0,h=0;e=e.tokenSort(),this.fillTokensGaps(e,t);for(let k,u=0,c=(e=e.tokenSort()).length;u<c;u++){(k=e[u]).source=t;let c=k.value,g=k.levels;switch(k.group){case i.Whitespace:k.type=r[k.value];break;case i.Block:k.type=n[c],"["===c?a++:"("===c?h++:"{"===c&&p++,g.brackets=a,g.braces=p,g.parens=h,"}"===c?p--:")"===c?h--:"]"===c&&a--;break;case i.Operator:k.type=o[c];break;case i.Other:if(l.includes(c))k.group=i.Keyword,k.type=c;else{let e;s.lastIndex=0,null!==(e=s.exec(c))&&e[0].length>0&&(k.group=i.Other,k.type="identifier")}}k.group!==i.Block&&(g.brackets=a,g.braces=p,g.parens=h)}return e}resetTokenPoints(e,t,s){let r=-1,n=s;for(;n<e.length;n++)if(e[n].pos>=t){r=n;break}if(n>=e.length)return r;for(t=e[n].pos;n<e.length&&e[n].pos===t;n++)r=n;return r}tokeniseLineComment(e,t,s,r){let n=t.length;for(let e=r+1,t=s.length;e<t;e++){let t=s[e],r=t.rxResult[0];if("\r\n"===r||"\n"===r){n=t.pos+t.rxResult[0].length-start;break}}return new e.tokenClass(start,n,e.tokenClass.Groups.Comment,"in-line")}tokeniseBlockComment(e,t,s,r){const n=e.pos;let o=t.length;for(let e=r+1,t=s.length;e<t;e++){let t=s[e],r=t.rxResult[0];if("*/"===r){o=t.pos+r.length-n;break}}return new e.tokenClass(n,o,e.tokenClass.Groups.Comment,"block")}tokeniseQuotes(e,t){const s=e.key;let r=e.pos,n=!0;for(r++;n;){let e=t.substr(r,1);if("\\"!==e){if(s===e||r>t.length){n=!1;break}r++}else r+=2}return new e.tokenClass(e.pos,r-e.pos+s.length,e.tokenClass.Groups.Quotes)}}